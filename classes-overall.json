[
  {
    "name": "Console",
    "body": "Class Console\r\n\t\r\n\t' Author: Uwe Keim\r\n\t' License: The Code Project Open License (CPOL)\r\n\t' https://www.codeproject.com/Articles/250/printf-like-Format-Function-in-VBScript\r\n\t''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\r\n\t' works like the printf-function in C.\r\n\t' takes a string with format characters and an array\r\n\t' to expand.\r\n\t'\r\n\t' the format characters are always \"%x\", independ of the\r\n\t' type.\r\n\t'\r\n\t' usage example:\r\n\t'\tdim str\r\n\t'\tstr = fmt( \"hello, Mr. %x, today's date is %x.\", Array(\"Miller\",Date) )\r\n\t'\tresponse.Write str\r\n\tPublic Function fmt( str, args )\r\n\t\tDim res\t\t' the result string.\r\n\t\tres = \"\"\r\n\t\t\r\n\t\tDim pos\t\t' the current position in the args array.\r\n\t\tpos = 0\r\n\t\t\r\n\t\tDim i\r\n\t\tFor i = 1 To Len(str)\r\n\t\t\t' found a fmt char.\r\n\t\t\tIf Mid(str,i,1)=\"%\" Then\r\n\t\t\t\tIf i<Len(str) Then\r\n\t\t\t\t\t' normal percent.\r\n\t\t\t\t\tIf Mid(str,i+1,1)=\"%\" Then\r\n\t\t\t\t\t\tres = res & \"%\"\r\n\t\t\t\t\t\ti = i + 1\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t' expand from array.\r\n\t\t\t\t\tElseIf Mid(str,i+1,1)=\"x\" Then\r\n\t\t\t\t\t\tres = res & CStr(args(pos))\r\n\t\t\t\t\t\tpos = pos+1\r\n\t\t\t\t\t\ti = i + 1\r\n\t\t\t\t\tEnd If\r\n\t\t\t\tEnd If\r\n\t\t\t\t\r\n\t\t\t\t' found a normal char.\r\n\t\t\tElse\r\n\t\t\t\tres = res & Mid(str,i,1)\r\n\t\t\tEnd If\r\n\t\tNext\r\n\t\t\r\n\t\tfmt = res\r\n\tEnd Function\r\n\t\r\nEnd Class",
    "pubFuncs": [
      "\tPublic Function fmt( str, args )\r\n\t\tDim res\t\t' the result string.\r\n\t\tres = \"\"\r\n\t\t\r\n\t\tDim pos\t\t' the current position in the args array.\r\n\t\tpos = 0\r\n\t\t\r\n\t\tDim i\r\n\t\tFor i = 1 To Len(str)\r\n\t\t\t' found a fmt char.\r\n\t\t\tIf Mid(str,i,1)=\"%\" Then\r\n\t\t\t\tIf i<Len(str) Then\r\n\t\t\t\t\t' normal percent.\r\n\t\t\t\t\tIf Mid(str,i+1,1)=\"%\" Then\r\n\t\t\t\t\t\tres = res & \"%\"\r\n\t\t\t\t\t\ti = i + 1\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t' expand from array.\r\n\t\t\t\t\tElseIf Mid(str,i+1,1)=\"x\" Then\r\n\t\t\t\t\t\tres = res & CStr(args(pos))\r\n\t\t\t\t\t\tpos = pos+1\r\n\t\t\t\t\t\ti = i + 1\r\n\t\t\t\t\tEnd If\r\n\t\t\t\tEnd If\r\n\t\t\t\t\r\n\t\t\t\t' found a normal char.\r\n\t\t\tElse\r\n\t\t\t\tres = res & Mid(str,i,1)\r\n\t\t\tEnd If\r\n\t\tNext\r\n\t\t\r\n\t\tfmt = res\r\n\tEnd Function"
    ],
    "remaining": "Class Console\r\n\t\r\n\t' Author: Uwe Keim\r\n\t' License: The Code Project Open License (CPOL)\r\n\t' https://www.codeproject.com/Articles/250/printf-like-Format-Function-in-VBScript\r\n\t''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\r\n\t' works like the printf-function in C.\r\n\t' takes a string with format characters and an array\r\n\t' to expand.\r\n\t'\r\n\t' the format characters are always \"%x\", independ of the\r\n\t' type.\r\n\t'\r\n\t' usage example:\r\n\t'\tdim str\r\n\t'\tstr = fmt( \"hello, Mr. %x, today's date is %x.\", Array(\"Miller\",Date) )\r\n\t'\tresponse.Write str\r\nPUB_FUN_0\r\n\t\r\nEnd Class"
  },
  {
    "name": "Collection",
    "extends": "Console",
    "body": "Class Collection extends Console\r\n\r\n    Private dict\r\n    Private oThis\r\n    Private m_Name\r\n\r\n    Private Sub Class_Initialize()\r\n        set dict = CreateObject(\"Scripting.Dictionary\")\r\n        set oThis = Me\r\n        m_Name = \"Undefined\"\r\n    End Sub\r\n\r\n    Public Default Property Get Obj\r\n        set Obj = dict\r\n    End Property \r\n    Public Property Set Obj(d)\r\n        set dict = d\r\n    End Property \r\n\r\n    Public Property Get Name\r\n        Name = m_Name\r\n    End Property\r\n    Public Property Let Name(Value)\r\n        m_Name = Value\r\n    End Property\r\n\r\n    Public Sub Add(Key, Value)\r\n        dict.Add key, value\r\n    End Sub ' Add\r\n\r\n    Public Sub Remove(Key)\r\n        If KeyExists(Key) Then\r\n            dict.Remove(Key)\r\n        Else\r\n            RaiseErr \"Key [\" & Key & \"] does not exists in collection.\"\r\n        End If\r\n    End Sub ' Remove\r\n\r\n    Public Sub RemoveAll()\r\n        dict.RemoveAll()\r\n    End Sub\r\n\r\n    Public Property Get Count\r\n        Count = dict.Count\r\n    End Property\r\n\r\n    Public Function GetItem(Key)\r\n        If KeyExists(Key) Then\r\n            GetItem = dict.Item(Key)\r\n        Else\r\n            'TODO: Should we raise an error?\r\n            RaiseErr \"Key [\" & Key & \"] does not exists in collection.\"\r\n        End If\r\n    End Function ' GetItem\r\n\r\n    Public Function GetItemAtIndex(Index)\r\n        'TODO: How to ensure Index is an integer?\r\n        GetItemAtIndex = dict.Item(Index)\r\n    End Function ' GetItemAtIndex\r\n\r\n\r\n    Public Function IndexOf(Key)\r\n        IndexOf = dict.IndexOf(Key, 0)\r\n    End Function\r\n\r\n    Public Function KeyExists(Key)\r\n        KeyExists = dict.Exists(Key)\r\n    End Function\r\n\r\n    Public Function toCSV\r\n        toCSV = join(toArray(), \", \")\r\n    End Function\r\n\r\n    Public Function toArray\r\n        toArray = dict.Items\r\n    End Function\r\n\r\n    Public Function isEmpty\r\n        isEmpty = (dict.Count = 0)        \r\n    End Function ' isEmpty\r\n    \r\n    ' Public Sub ReverseKeys\r\n\r\n    '     Dim i, j, last, half, temp, arr\r\n    '     arr = dict.Keys\r\n    '     WScript.Echo join(arr, \", \")\r\n    '     last = UBound(arr)\r\n    '     half = Int(last/2)\r\n\r\n    '     For i = 0 To half\r\n    '         temp = arr(i)\r\n    '         arr(i) = arr(last-i)\r\n    '         arr(last-i) = temp\r\n    '     Next\r\n        \r\n    '     WScript.Echo join(arr, \", \")\r\n\r\n    '     dim dict1\r\n    '     set dict1 = New Collection\r\n    '     for i = 0 to UBound(arr)\r\n    '         dict1.Add arr(i), arr(i) & \"1\"\r\n    '     next\r\n    '     'WScript.Echo dict1.toCSV\r\n    '     ' RemoveAll\r\n    '     set dict = dict1\r\n\r\n    ' End Sub\r\n\r\n    ' list.Sort (available in DictUtil)\r\n    ' list.Reverse\r\n        ' for each k in dict.Keys\r\n        '     if k = Key Then\r\n        '         KeyExists = true\r\n        '         Exit Function\r\n        '     End If\r\n        ' next\r\n\r\n\r\n    Private Sub RaiseErr(desc)\r\n        Err.Clear\r\n        Err.Raise 1000, \"Collection Class Error\", desc\r\n    End Sub\r\n\r\n    Private Sub Class_Terminate()\r\n        set dict = Nothing\r\n        set oThis = Nothing\r\n    End Sub\r\n\r\nEnd Class ",
    "pubProps": [
      "    Public Property Set Obj(d)\r\n        set dict = d\r\n    End Property ",
      "    Public Property Get Name\r\n        Name = m_Name\r\n    End Property",
      "    Public Property Let Name(Value)\r\n        m_Name = Value\r\n    End Property",
      "    Public Property Get Count\r\n        Count = dict.Count\r\n    End Property"
    ],
    "pubSubs": [
      "    Public Sub Add(Key, Value)\r\n        dict.Add key, value\r\n    End Sub ",
      "    Public Sub Remove(Key)\r\n        If KeyExists(Key) Then\r\n            dict.Remove(Key)\r\n        Else\r\n            RaiseErr \"Key [\" & Key & \"] does not exists in collection.\"\r\n        End If\r\n    End Sub ",
      "    Public Sub RemoveAll()\r\n        dict.RemoveAll()\r\n    End Sub",
      " Public Sub ReverseKeys\r\n\r\n    '     Dim i, j, last, half, temp, arr\r\n    '     arr = dict.Keys\r\n    '     WScript.Echo join(arr, \", \")\r\n    '     last = UBound(arr)\r\n    '     half = Int(last/2)\r\n\r\n    '     For i = 0 To half\r\n    '         temp = arr(i)\r\n    '         arr(i) = arr(last-i)\r\n    '         arr(last-i) = temp\r\n    '     Next\r\n        \r\n    '     WScript.Echo join(arr, \", \")\r\n\r\n    '     dim dict1\r\n    '     set dict1 = New Collection\r\n    '     for i = 0 to UBound(arr)\r\n    '         dict1.Add arr(i), arr(i) & \"1\"\r\n    '     next\r\n    '     'WScript.Echo dict1.toCSV\r\n    '     ' RemoveAll\r\n    '     set dict = dict1\r\n\r\n    ' End Sub"
    ],
    "pubFuncs": [
      "    Public Function GetItem(Key)\r\n        If KeyExists(Key) Then\r\n            GetItem = dict.Item(Key)\r\n        Else\r\n            'TODO: Should we raise an error?\r\n            RaiseErr \"Key [\" & Key & \"] does not exists in collection.\"\r\n        End If\r\n    End Function ",
      "    Public Function GetItemAtIndex(Index)\r\n        'TODO: How to ensure Index is an integer?\r\n        GetItemAtIndex = dict.Item(Index)\r\n    End Function ",
      "    Public Function IndexOf(Key)\r\n        IndexOf = dict.IndexOf(Key, 0)\r\n    End Function",
      "    Public Function KeyExists(Key)\r\n        KeyExists = dict.Exists(Key)\r\n    End Function",
      "    Public Function toCSV\r\n        toCSV = join(toArray(), \", \")\r\n    End Function",
      "    Public Function toArray\r\n        toArray = dict.Items\r\n    End Function",
      "    Public Function isEmpty\r\n        isEmpty = (dict.Count = 0)        \r\n    End Function "
    ],
    "remaining": "Class Collection extends Console\r\n\r\n    Private dict\r\n    Private oThis\r\n    Private m_Name\r\n\r\n    Private Sub Class_Initialize()\r\n        set dict = CreateObject(\"Scripting.Dictionary\")\r\n        set oThis = Me\r\n        m_Name = \"Undefined\"\r\n    End Sub\r\n\r\n    Public Default Property Get Obj\r\n        set Obj = dict\r\n    End Property \r\nPUB_PROP_0\r\n\r\nPUB_PROP_1\r\nPUB_PROP_2\r\n\r\nPUB_SUB_0' Add\r\n\r\nPUB_SUB_1' Remove\r\n\r\nPUB_SUB_2\r\n\r\nPUB_PROP_3\r\n\r\nPUB_FUN_0' GetItem\r\n\r\nPUB_FUN_1' GetItemAtIndex\r\n\r\n\r\nPUB_FUN_2\r\n\r\nPUB_FUN_3\r\n\r\nPUB_FUN_4\r\n\r\nPUB_FUN_5\r\n\r\nPUB_FUN_6' isEmpty\r\n    \r\n    'PUB_SUB_3\r\n\r\n    ' list.Sort (available in DictUtil)\r\n    ' list.Reverse\r\n        ' for each k in dict.Keys\r\n        '     if k = Key Then\r\n        '         KeyExists = true\r\n        '         Exit Function\r\n        '     End If\r\n        ' next\r\n\r\n\r\n    Private Sub RaiseErr(desc)\r\n        Err.Clear\r\n        Err.Raise 1000, \"Collection Class Error\", desc\r\n    End Sub\r\n\r\n    Private Sub Class_Terminate()\r\n        set dict = Nothing\r\n        set oThis = Nothing\r\n    End Sub\r\n\r\nEnd Class "
  },
  {
    "name": "DictUtil",
    "body": "Class DictUtil\r\n    \r\n    ' Author: Dale Fugier <https://developer.rhino3d.com/authors/dale_fugier>\r\n    ' Source: https://developer.rhino3d.com/guides/rhinoscript/vbscript-dictionaries/\r\n    ' Description:\r\n    '   Sorts a dictionary by either key or item\r\n    ' Parameters:\r\n    '   objDict - the dictionary to sort\r\n    '   intSort - the field to sort (1=key, 2=item)\r\n    ' Returns:\r\n    '   A dictionary sorted by intSort\r\n    ''' <summary>Sorts a dictionary by either key or item</summary>\r\n\t''' <param name=\"objDict\">The dictionary to sort</param>\r\n\t''' <param name=\"intSort\">The field to sort (1=key, 2=item)</param>\r\n    Function SortDictionary(objDict, intSort)\r\n\r\n        ' declare constants\r\n        Const dictKey  = 1\r\n        Const dictItem = 2\r\n\r\n        ' declare our variables\r\n        Dim strDict()\r\n        Dim objKey\r\n        Dim strKey,strItem\r\n        Dim X,Y,Z\r\n\r\n        ' get the dictionary count\r\n        Z = objDict.Count\r\n\r\n        ' we need more than one item to warrant sorting\r\n        If Z > 1 Then\r\n            ' create an array to store dictionary information\r\n            ReDim strDict(Z,2)\r\n            X = 0\r\n            ' populate the string array\r\n            For Each objKey In objDict\r\n                strDict(X,dictKey)  = CStr(objKey)\r\n                strDict(X,dictItem) = CStr(objDict(objKey))\r\n                X = X + 1\r\n            Next\r\n\r\n            ' perform a a shell sort of the string array\r\n            For X = 0 To (Z - 2)\r\n            For Y = X To (Z - 1)\r\n                If StrComp(strDict(X,intSort),strDict(Y,intSort),vbTextCompare) > 0 Then\r\n                    strKey  = strDict(X,dictKey)\r\n                    strItem = strDict(X,dictItem)\r\n                    strDict(X,dictKey)  = strDict(Y,dictKey)\r\n                    strDict(X,dictItem) = strDict(Y,dictItem)\r\n                    strDict(Y,dictKey)  = strKey\r\n                    strDict(Y,dictItem) = strItem\r\n                End If\r\n            Next\r\n            Next\r\n\r\n            ' erase the contents of the dictionary object\r\n            objDict.RemoveAll\r\n\r\n            ' repopulate the dictionary with the sorted information\r\n            For X = 0 To (Z - 1)\r\n            objDict.Add strDict(X,dictKey), strDict(X,dictItem)\r\n            Next\r\n\r\n        End If\r\n    End Function\r\nEnd Class",
    "remaining": "Class DictUtil\r\n    \r\n    ' Author: Dale Fugier <https://developer.rhino3d.com/authors/dale_fugier>\r\n    ' Source: https://developer.rhino3d.com/guides/rhinoscript/vbscript-dictionaries/\r\n    ' Description:\r\n    '   Sorts a dictionary by either key or item\r\n    ' Parameters:\r\n    '   objDict - the dictionary to sort\r\n    '   intSort - the field to sort (1=key, 2=item)\r\n    ' Returns:\r\n    '   A dictionary sorted by intSort\r\n    ''' <summary>Sorts a dictionary by either key or item</summary>\r\n\t''' <param name=\"objDict\">The dictionary to sort</param>\r\n\t''' <param name=\"intSort\">The field to sort (1=key, 2=item)</param>\r\n    Function SortDictionary(objDict, intSort)\r\n\r\n        ' declare constants\r\n        Const dictKey  = 1\r\n        Const dictItem = 2\r\n\r\n        ' declare our variables\r\n        Dim strDict()\r\n        Dim objKey\r\n        Dim strKey,strItem\r\n        Dim X,Y,Z\r\n\r\n        ' get the dictionary count\r\n        Z = objDict.Count\r\n\r\n        ' we need more than one item to warrant sorting\r\n        If Z > 1 Then\r\n            ' create an array to store dictionary information\r\n            ReDim strDict(Z,2)\r\n            X = 0\r\n            ' populate the string array\r\n            For Each objKey In objDict\r\n                strDict(X,dictKey)  = CStr(objKey)\r\n                strDict(X,dictItem) = CStr(objDict(objKey))\r\n                X = X + 1\r\n            Next\r\n\r\n            ' perform a a shell sort of the string array\r\n            For X = 0 To (Z - 2)\r\n            For Y = X To (Z - 1)\r\n                If StrComp(strDict(X,intSort),strDict(Y,intSort),vbTextCompare) > 0 Then\r\n                    strKey  = strDict(X,dictKey)\r\n                    strItem = strDict(X,dictItem)\r\n                    strDict(X,dictKey)  = strDict(Y,dictKey)\r\n                    strDict(X,dictItem) = strDict(Y,dictItem)\r\n                    strDict(Y,dictKey)  = strKey\r\n                    strDict(Y,dictItem) = strItem\r\n                End If\r\n            Next\r\n            Next\r\n\r\n            ' erase the contents of the dictionary object\r\n            objDict.RemoveAll\r\n\r\n            ' repopulate the dictionary with the sorted information\r\n            For X = 0 To (Z - 1)\r\n            objDict.Add strDict(X,dictKey), strDict(X,dictItem)\r\n            Next\r\n\r\n        End If\r\n    End Function\r\nEnd Class"
  },
  {
    "name": "ArrayUtil",
    "body": "Class ArrayUtil\r\n\t\r\n\tPublic Function toString(arr)\r\n\t\tIf Not isArray(arr) Then\r\n\t\t\ttoString = \"Supplied parameter is not an array.\"\r\n\t\t\tExit Function\r\n\t\tEnd If\r\n\t\t\r\n\t\tDim s, i\r\n\t\ts = \"Array{\" & UBound(arr) & \"} [\" & vbCrLf\r\n\t\tFor i = 0  To UBound(arr)\r\n\t\t\ts = s & vbTab & \"[\" & i & \"] => [\" & arr(i) & \"]\"\r\n\t\t\tIf i < UBound(arr) Then s = s & \", \"\r\n\t\t\ts = s &  vbCrLf\r\n\t\tNext\r\n\t\ts = s & \"]\"\r\n\t\ttoString = s\r\n\t\t\r\n\tEnd Function\r\n\t\r\n\tPublic Function contains(arr, s) \r\n\t\tIf Not isArray(arr) Then\r\n\t\t\ttoString = \"Supplied parameter is not an array.\"\r\n\t\t\tExit Function\r\n\t\tEnd If\r\n\t\t\r\n\t\tDim i, bFlag\r\n\t\tbFlag = False\r\n\t\tFor i = 0  To UBound(arr)\r\n\t\t\tIf arr(i) = s Then\r\n\t\t\t\tbFlag = True\r\n\t\t\t\tExit For\r\n\t\t\tEnd If\r\n\t\tNext\r\n\t\tcontains = bFlag\r\n\tEnd Function\r\n\t\r\n\t'TODO: Add functionality to manage Array (redim, get last, add new etc.,)\r\n\t'TODO: With ability to sort, reverse, avoid duplicates etc.,\r\nEnd Class",
    "pubFuncs": [
      "\tPublic Function toString(arr)\r\n\t\tIf Not isArray(arr) Then\r\n\t\t\ttoString = \"Supplied parameter is not an array.\"\r\n\t\t\tExit Function\r\n\t\tEnd If\r\n\t\t\r\n\t\tDim s, i\r\n\t\ts = \"Array{\" & UBound(arr) & \"} [\" & vbCrLf\r\n\t\tFor i = 0  To UBound(arr)\r\n\t\t\ts = s & vbTab & \"[\" & i & \"] => [\" & arr(i) & \"]\"\r\n\t\t\tIf i < UBound(arr) Then s = s & \", \"\r\n\t\t\ts = s &  vbCrLf\r\n\t\tNext\r\n\t\ts = s & \"]\"\r\n\t\ttoString = s\r\n\t\t\r\n\tEnd Function",
      "\tPublic Function contains(arr, s) \r\n\t\tIf Not isArray(arr) Then\r\n\t\t\ttoString = \"Supplied parameter is not an array.\"\r\n\t\t\tExit Function\r\n\t\tEnd If\r\n\t\t\r\n\t\tDim i, bFlag\r\n\t\tbFlag = False\r\n\t\tFor i = 0  To UBound(arr)\r\n\t\t\tIf arr(i) = s Then\r\n\t\t\t\tbFlag = True\r\n\t\t\t\tExit For\r\n\t\t\tEnd If\r\n\t\tNext\r\n\t\tcontains = bFlag\r\n\tEnd Function"
    ],
    "remaining": "Class ArrayUtil\r\n\t\r\nPUB_FUN_0\r\n\t\r\nPUB_FUN_1\r\n\t\r\n\t'TODO: Add functionality to manage Array (redim, get last, add new etc.,)\r\n\t'TODO: With ability to sort, reverse, avoid duplicates etc.,\r\nEnd Class"
  },
  {
    "name": "PathUtil",
    "body": "Class PathUtil\r\n\t\r\n\tPrivate Property Get DOT\r\n\tDOT = \".\"\r\n\tEnd Property\r\n\tPrivate Property Get DOTDOT\r\n\tDOTDOT = \"..\"\r\n\tEnd Property\r\n\t\r\n\tPrivate oFSO\r\n\tPrivate m_base\r\n\tPrivate m_script\r\n\tPrivate m_temp\r\n\t\r\n\tPrivate Sub Class_Initialize()\r\n\t\tSet oFSO = CreateObject(\"Scripting.FileSystemObject\")\r\n\t\tm_script = Left(WScript.ScriptFullName,InStrRev(WScript.ScriptFullName,\"\\\")-1)\r\n\t\tm_base = m_script\r\n\t\tm_temp = Array()\r\n\t\tReDim Preserve m_temp(0)\r\n\t\tm_temp(0) = m_script\r\n\tEnd Sub\r\n\t\r\n\tPublic Property Get ScriptPath\r\n\tScriptPath = m_script\r\n\tEnd Property\r\n\t\r\n\tPublic Property Get BasePath\r\n\tBasePath = m_base\r\n\tEnd Property\r\n\t\r\n\tPublic Property Let BasePath(path)\r\n\tDo While endsWith(path, \"\\\")\r\n\t\tpath = Left(Path, Len(path)-1)\r\n\tLoop\r\n\tm_base = Resolve(path)\r\n\tEchoDX \"New Base Path: %x\", m_base\r\n\tEnd Property\r\n\t\r\n\tPublic Property Get TempBasePath\r\n\tTempBasePath = m_temp(UBound(m_temp))\r\n\tEnd Property\r\n\t\r\n\tPublic Property Let TempBasePath(path)\r\n\tDo While endsWith(path, \"\\\")\r\n\t\tpath = Left(Path, Len(path)-1)\r\n\tLoop\r\n\tIf arrUtil.contains(m_temp, path) Then\r\n\t\tEchoDX \"Temp Path %x already exists; skipped\", path\r\n\tElse\r\n\t\tReDim Preserve m_temp(Ubound(m_temp)+1)\r\n\t\tm_temp(Ubound(m_temp)) = Resolve(path)\r\n\t\tEchoDX \"New Temp Base Path: %x\", m_temp(Ubound(m_temp))\r\n\tEnd If\r\n\tEnd Property\r\n\t\r\n\tFunction Resolve(path)\r\n\t\tDim pathBase, lPath, final\r\n\t\tEchoDX \"path: %x\", path\r\n\t\tIf path = DOT Or path = DOTDOT Then\r\n\t\t\tpath = path & \"\\\"\r\n\t\tEnd If\r\n\t\tEchoDX \"path: %x\", path\r\n\t\t\r\n\t\tIf oFSO.FolderExists(path) Then\r\n\t\t\tEchoD \"FolderExists\"\r\n\t\t\tResolve = oFSO.GetFolder(path).path\r\n\t\t\tExit Function\r\n\t\tEnd If\r\n\t\t\r\n\t\tIf oFSO.FileExists(path) Then\r\n\t\t\tEchoD \"FileExists\"\r\n\t\t\tResolve = oFSO.GetFile(path).path\r\n\t\t\tExit Function\r\n\t\tEnd If\r\n\t\t\r\n\t\tpathBase = oFSO.BuildPath(m_base, path)\r\n\t\tEchoDX \"Adding base %x to path %x. New Path: %x\", Array(m_base, path, pathBase)\r\n\t\t\r\n\t\tIf endsWith(pathBase, \"\\\") Then\r\n\t\t\tIf isObject(oFSO.GetFolder(pathBase)) Then\r\n\t\t\t\tEchoD \"EndsWith '\\' -> FolderExists\"\r\n\t\t\t\tResolve = oFSO.GetFolder(pathBase).Path\r\n\t\t\t\tExit Function\r\n\t\t\tEnd If\r\n\t\tElse\r\n\t\t\t\r\n\t\t\tIf oFSO.FolderExists(pathBase) Then\r\n\t\t\t\tEchoD \"FolderExists\"\r\n\t\t\t\tResolve = oFSO.GetFolder(pathBase).path\r\n\t\t\t\tExit Function\r\n\t\t\tEnd If\r\n\t\t\t\r\n\t\t\tIf oFSO.FileExists(pathBase) Then\r\n\t\t\t\tEchoD \"FileExists\"\r\n\t\t\t\tResolve = oFSO.GetFile(pathBase).path\r\n\t\t\t\tExit Function\r\n\t\t\tEnd If\r\n\t\t\t\r\n\t\t\tDim i\r\n\t\t\ti = Ubound(m_temp)\r\n\t\t\tDo\r\n\t\t\t\tlPath = oFSO.BuildPath(m_temp(i), path)\r\n\t\t\t\tEchoDX \"Adding Temp Base path (%x) %x to path %x. New Path: %x\", Array(i, m_temp(i), path, lPath)\r\n\t\t\t\tIf oFSO.FileExists(lPath) Then\r\n\t\t\t\t\tfinal = oFSO.GetFile(lPath).path\r\n\t\t\t\t\tEchoDX \"File Resolved with Temp Base %x\", final\r\n\t\t\t\t\tResolve = final\r\n\t\t\t\t\tExit Function\r\n\t\t\t\tEnd If\r\n\t\t\t\tIf oFSO.FolderExists(lPath) Then\r\n\t\t\t\t\tfinal = oFSO.GetFolder(lPath)\r\n\t\t\t\t\tEchoDX \"Folder Resolved with Temp Base %x\", final\r\n\t\t\t\t\tResolve = final\r\n\t\t\t\t\tExit Function\r\n\t\t\t\tEnd If\r\n\t\t\t\ti = i - 1\r\n\t\t\tLoop While i >= 0\r\n\t\t\t\r\n\t\t\tlPath = oFSO.BuildPath(m_script, path)\r\n\t\t\tEchoDX \"Adding script path %x to path %x. New Path: %x\", Array(m_script, path, lPath)\r\n\t\t\tIf oFSO.FileExists(lPath) Then\r\n\t\t\t\tfinal = oFSO.GetFile(lPath).path\r\n\t\t\t\tEchoDX \"File Resolved with Temp Base %x\", final\r\n\t\t\t\tResolve = final\r\n\t\t\t\tExit Function\r\n\t\t\tEnd If\r\n\t\t\tIf oFSO.FolderExists(lPath) Then\r\n\t\t\t\tfinal = oFSO.GetFolder(lPath)\r\n\t\t\t\tEchoDX \"Folder Resolved with Temp Base %x\", final\r\n\t\t\t\tResolve = final\r\n\t\t\t\tExit Function\r\n\t\t\tEnd If\r\n\t\tEnd If\r\n\t\t\r\n\t\tEchoD \"Unable to Resolve\"\r\n\t\tResolve = path\r\n\tEnd Function ' Resolve\r\n\t\r\n\tPrivate Sub Class_Terminate()\r\n\t\tSet oFSO = Nothing\r\n\tEnd Sub\r\n\t\r\nEnd Class ",
    "pubProps": [
      "\tPublic Property Get ScriptPath\r\n\tScriptPath = m_script\r\n\tEnd Property",
      "\tPublic Property Get BasePath\r\n\tBasePath = m_base\r\n\tEnd Property",
      "\tPublic Property Let BasePath(path)\r\n\tDo While endsWith(path, \"\\\")\r\n\t\tpath = Left(Path, Len(path)-1)\r\n\tLoop\r\n\tm_base = Resolve(path)\r\n\tEchoDX \"New Base Path: %x\", m_base\r\n\tEnd Property",
      "\tPublic Property Get TempBasePath\r\n\tTempBasePath = m_temp(UBound(m_temp))\r\n\tEnd Property",
      "\tPublic Property Let TempBasePath(path)\r\n\tDo While endsWith(path, \"\\\")\r\n\t\tpath = Left(Path, Len(path)-1)\r\n\tLoop\r\n\tIf arrUtil.contains(m_temp, path) Then\r\n\t\tEchoDX \"Temp Path %x already exists; skipped\", path\r\n\tElse\r\n\t\tReDim Preserve m_temp(Ubound(m_temp)+1)\r\n\t\tm_temp(Ubound(m_temp)) = Resolve(path)\r\n\t\tEchoDX \"New Temp Base Path: %x\", m_temp(Ubound(m_temp))\r\n\tEnd If\r\n\tEnd Property"
    ],
    "remaining": "Class PathUtil\r\n\t\r\n\tPrivate Property Get DOT\r\n\tDOT = \".\"\r\n\tEnd Property\r\n\tPrivate Property Get DOTDOT\r\n\tDOTDOT = \"..\"\r\n\tEnd Property\r\n\t\r\n\tPrivate oFSO\r\n\tPrivate m_base\r\n\tPrivate m_script\r\n\tPrivate m_temp\r\n\t\r\n\tPrivate Sub Class_Initialize()\r\n\t\tSet oFSO = CreateObject(\"Scripting.FileSystemObject\")\r\n\t\tm_script = Left(WScript.ScriptFullName,InStrRev(WScript.ScriptFullName,\"\\\")-1)\r\n\t\tm_base = m_script\r\n\t\tm_temp = Array()\r\n\t\tReDim Preserve m_temp(0)\r\n\t\tm_temp(0) = m_script\r\n\tEnd Sub\r\n\t\r\nPUB_PROP_0\r\n\t\r\nPUB_PROP_1\r\n\t\r\nPUB_PROP_2\r\n\t\r\nPUB_PROP_3\r\n\t\r\nPUB_PROP_4\r\n\t\r\n\tFunction Resolve(path)\r\n\t\tDim pathBase, lPath, final\r\n\t\tEchoDX \"path: %x\", path\r\n\t\tIf path = DOT Or path = DOTDOT Then\r\n\t\t\tpath = path & \"\\\"\r\n\t\tEnd If\r\n\t\tEchoDX \"path: %x\", path\r\n\t\t\r\n\t\tIf oFSO.FolderExists(path) Then\r\n\t\t\tEchoD \"FolderExists\"\r\n\t\t\tResolve = oFSO.GetFolder(path).path\r\n\t\t\tExit Function\r\n\t\tEnd If\r\n\t\t\r\n\t\tIf oFSO.FileExists(path) Then\r\n\t\t\tEchoD \"FileExists\"\r\n\t\t\tResolve = oFSO.GetFile(path).path\r\n\t\t\tExit Function\r\n\t\tEnd If\r\n\t\t\r\n\t\tpathBase = oFSO.BuildPath(m_base, path)\r\n\t\tEchoDX \"Adding base %x to path %x. New Path: %x\", Array(m_base, path, pathBase)\r\n\t\t\r\n\t\tIf endsWith(pathBase, \"\\\") Then\r\n\t\t\tIf isObject(oFSO.GetFolder(pathBase)) Then\r\n\t\t\t\tEchoD \"EndsWith '\\' -> FolderExists\"\r\n\t\t\t\tResolve = oFSO.GetFolder(pathBase).Path\r\n\t\t\t\tExit Function\r\n\t\t\tEnd If\r\n\t\tElse\r\n\t\t\t\r\n\t\t\tIf oFSO.FolderExists(pathBase) Then\r\n\t\t\t\tEchoD \"FolderExists\"\r\n\t\t\t\tResolve = oFSO.GetFolder(pathBase).path\r\n\t\t\t\tExit Function\r\n\t\t\tEnd If\r\n\t\t\t\r\n\t\t\tIf oFSO.FileExists(pathBase) Then\r\n\t\t\t\tEchoD \"FileExists\"\r\n\t\t\t\tResolve = oFSO.GetFile(pathBase).path\r\n\t\t\t\tExit Function\r\n\t\t\tEnd If\r\n\t\t\t\r\n\t\t\tDim i\r\n\t\t\ti = Ubound(m_temp)\r\n\t\t\tDo\r\n\t\t\t\tlPath = oFSO.BuildPath(m_temp(i), path)\r\n\t\t\t\tEchoDX \"Adding Temp Base path (%x) %x to path %x. New Path: %x\", Array(i, m_temp(i), path, lPath)\r\n\t\t\t\tIf oFSO.FileExists(lPath) Then\r\n\t\t\t\t\tfinal = oFSO.GetFile(lPath).path\r\n\t\t\t\t\tEchoDX \"File Resolved with Temp Base %x\", final\r\n\t\t\t\t\tResolve = final\r\n\t\t\t\t\tExit Function\r\n\t\t\t\tEnd If\r\n\t\t\t\tIf oFSO.FolderExists(lPath) Then\r\n\t\t\t\t\tfinal = oFSO.GetFolder(lPath)\r\n\t\t\t\t\tEchoDX \"Folder Resolved with Temp Base %x\", final\r\n\t\t\t\t\tResolve = final\r\n\t\t\t\t\tExit Function\r\n\t\t\t\tEnd If\r\n\t\t\t\ti = i - 1\r\n\t\t\tLoop While i >= 0\r\n\t\t\t\r\n\t\t\tlPath = oFSO.BuildPath(m_script, path)\r\n\t\t\tEchoDX \"Adding script path %x to path %x. New Path: %x\", Array(m_script, path, lPath)\r\n\t\t\tIf oFSO.FileExists(lPath) Then\r\n\t\t\t\tfinal = oFSO.GetFile(lPath).path\r\n\t\t\t\tEchoDX \"File Resolved with Temp Base %x\", final\r\n\t\t\t\tResolve = final\r\n\t\t\t\tExit Function\r\n\t\t\tEnd If\r\n\t\t\tIf oFSO.FolderExists(lPath) Then\r\n\t\t\t\tfinal = oFSO.GetFolder(lPath)\r\n\t\t\t\tEchoDX \"Folder Resolved with Temp Base %x\", final\r\n\t\t\t\tResolve = final\r\n\t\t\t\tExit Function\r\n\t\t\tEnd If\r\n\t\tEnd If\r\n\t\t\r\n\t\tEchoD \"Unable to Resolve\"\r\n\t\tResolve = path\r\n\tEnd Function ' Resolve\r\n\t\r\n\tPrivate Sub Class_Terminate()\r\n\t\tSet oFSO = Nothing\r\n\tEnd Sub\r\n\t\r\nEnd Class "
  },
  {
    "name": "FSO",
    "body": " class\r\n' Author: Praveen Nandagiri (pravynandas@gmail.com)\r\n' ==============================================================================================\r\n\r\nClass FSO\r\n\tPrivate dir\r\n\tPrivate objFSO\r\n\t\r\n\tPrivate Sub Class_Initialize\r\n\t\tSet objFSO = CreateObject(\"Scripting.FileSystemObject\")\r\n\t\tdir = Left(WScript.ScriptFullName,InStrRev(WScript.ScriptFullName,\"\\\"))\r\n\tEnd Sub\r\n\t\r\n\t' Update the current directory of the instance if needed\r\n\tPublic Sub setDir(s)\r\n\t\tdir = s\r\n\tEnd Sub\r\n\t\r\n\tPublic Function getDir\r\n\t\tgetDir = dir\r\n\tEnd Function\r\n\t\r\n\tPublic Function GetFSO\r\n\t\tSet GetFSO = objFSO\r\n\tEnd Function\r\n\t\r\n\tPublic Function FolderExists(fol)\r\n\t\tFolderExists = objFSO.FolderExists(fol)\r\n\tEnd Function\r\n\t\r\n\t' ===================== Sub Routines =====================\r\n\t\r\n\tPublic Function CreateFolder(fol)\r\n\t\tCreateFolder = False\r\n\t\tIf FolderExists(fol) Then\r\n\t\t\tCreateFolder = True\r\n\t\tElse\r\n\t\t\tobjFSO.CreateFolder(fol)\r\n\t\t\tCreateFolder = FolderExists(fol)\r\n\t\tEnd If\r\n\tEnd Function\r\n\t\r\n\tPublic Sub WriteFile(strFileName, strMessage, overwrite)\r\n\t\tConst ForReading = 1\r\n\t\tConst ForWriting = 2\r\n\t\tConst ForAppending = 8\r\n\t\tDim mode\r\n\t\tDim oFile\r\n\t\t\r\n\t\tmode = ForWriting\r\n\t\tIf Not overwrite Then\r\n\t\t\tmode = ForAppending\r\n\t\tEnd If\r\n\t\t\r\n\t\tIf objFSO.FileExists(strFileName) Then\r\n\t\t\tSet oFile = objFSO.OpenTextFile(strFileName, mode)\r\n\t\tElse\r\n\t\t\tSet oFile = objFSO.CreateTextFile(strFileName)\r\n\t\tEnd If\r\n\t\toFile.WriteLine strMessage\r\n\t\t\r\n\t\toFile.Close\r\n\t\t\r\n\t\tSet oFile = Nothing\r\n\tEnd Sub \r\n\t\r\n\t' ===================== Function Routines =====================\r\n\t\r\n\tPublic Function GetFileDir(ByVal file)\r\n\t\tEchoDX \"GetFileDir( %x )\", Array(file)\r\n\t\tDim objFile\r\n\t\tSet objFile = objFSO.GetFile(file)\r\n\t\tGetFileDir = objFSO.GetParentFolderName(objFile) \r\n\tEnd Function\r\n\t\r\n\tPublic Function GetFilePath(ByVal file)\r\n\t\tEchoDX \"GetFilePath( %x )\", Array(file)\r\n\t\tDim objFile\r\n\t\tOn Error Resume Next\r\n\t\tSet objFile = objFSO.GetFile(file)\r\n\t\tOn Error GoTo 0\r\n\t\tIf IsObject(objFile) Then\r\n\t\t\tGetFilePath = objFile.Path \r\n\t\tElse\r\n\t\t\tEchoDX \"File %x not found; searching in directory %x\", Array(file,dir)\r\n\t\t\tOn Error Resume Next\r\n\t\t\tSet objFile = objFile.GetFile(objFSO.BuildPath(dir, file))\r\n\t\t\tOn Error GoTo 0\r\n\t\t\tIf IsObject(objFile) Then\r\n\t\t\t\tGetFilePath = objFile.Path \r\n\t\t\tElse\r\n\t\t\t\tGetFilePath = \"File [\" & file & \"] Not found\"\r\n\t\t\tEnd If\r\n\t\tEnd If\r\n\tEnd Function\r\n\t\r\n\t''' <summary>Returns a specified number of characters from a string.</summary>\r\n\t''' <param name=\"file\">File Name</param>\r\n\tPublic Function GetFileName(ByVal file)\r\n\t\tGetFileName = objFSO.GetFile(file).Name\r\n\tEnd Function\r\n\t\r\n\tPublic Function GetFileExtn(file)\r\n\t\tGetFileExtn = \"\"\r\n\t\tOn Error Resume Next\r\n\t\tGetFileExtn = LCASE(objFSO.GetExtensionName(file))\r\n\t\tOn Error GoTo 0\r\n\tEnd Function\r\n\t\r\n\tPublic Function GetBaseName(ByVal file)\r\n\t\tGetBaseName = Replace(GetFileName(file), \".\" & GetFileExtn(file), \"\")\r\n\tEnd Function\r\n\t\r\n\tPublic Function ReadFile(file)\r\n\t\tfile = putil.Resolve(file)\r\n\t\tEchoDX \"---> File resolved to: %x\", Array(file)\r\n\t\tIf Not FileExists(file) Then \r\n\t\t\tWscript.Echo \"---> File \" & file & \" does not exists.\"\r\n\t\t\tReadFile = \"\"\r\n\t\t\tExit Function\r\n\t\tEnd If\r\n\t\tDim objFile: Set objFile = objFSO.OpenTextFile(file)\r\n\t\tReadFile = objFile.ReadAll()\r\n\t\tobjFile.Close\r\n\tEnd Function\r\n\t\r\n\tPublic Function FileExists(file)\r\n\t\tFileExists = objFSO.FileExists(file)\r\n\tEnd Function\r\n\t\r\n\tPublic Sub DeleteFile(file)\r\n\t\tOn Error Resume Next\r\n\t\tobjFSO.DeleteFile(file)\r\n\t\tOn Error GoTo 0\r\n\tEnd Sub\r\n\t\r\nEnd Class",
    "pubSubs": [
      "\tPublic Sub setDir(s)\r\n\t\tdir = s\r\n\tEnd Sub",
      "\tPublic Sub WriteFile(strFileName, strMessage, overwrite)\r\n\t\tConst ForReading = 1\r\n\t\tConst ForWriting = 2\r\n\t\tConst ForAppending = 8\r\n\t\tDim mode\r\n\t\tDim oFile\r\n\t\t\r\n\t\tmode = ForWriting\r\n\t\tIf Not overwrite Then\r\n\t\t\tmode = ForAppending\r\n\t\tEnd If\r\n\t\t\r\n\t\tIf objFSO.FileExists(strFileName) Then\r\n\t\t\tSet oFile = objFSO.OpenTextFile(strFileName, mode)\r\n\t\tElse\r\n\t\t\tSet oFile = objFSO.CreateTextFile(strFileName)\r\n\t\tEnd If\r\n\t\toFile.WriteLine strMessage\r\n\t\t\r\n\t\toFile.Close\r\n\t\t\r\n\t\tSet oFile = Nothing\r\n\tEnd Sub ",
      "\tPublic Sub DeleteFile(file)\r\n\t\tOn Error Resume Next\r\n\t\tobjFSO.DeleteFile(file)\r\n\t\tOn Error GoTo 0\r\n\tEnd Sub"
    ],
    "pubFuncs": [
      "\tPublic Function getDir\r\n\t\tgetDir = dir\r\n\tEnd Function",
      "\tPublic Function GetFSO\r\n\t\tSet GetFSO = objFSO\r\n\tEnd Function",
      "\tPublic Function FolderExists(fol)\r\n\t\tFolderExists = objFSO.FolderExists(fol)\r\n\tEnd Function",
      "\tPublic Function CreateFolder(fol)\r\n\t\tCreateFolder = False\r\n\t\tIf FolderExists(fol) Then\r\n\t\t\tCreateFolder = True\r\n\t\tElse\r\n\t\t\tobjFSO.CreateFolder(fol)\r\n\t\t\tCreateFolder = FolderExists(fol)\r\n\t\tEnd If\r\n\tEnd Function",
      "\tPublic Function GetFileDir(ByVal file)\r\n\t\tEchoDX \"GetFileDir( %x )\", Array(file)\r\n\t\tDim objFile\r\n\t\tSet objFile = objFSO.GetFile(file)\r\n\t\tGetFileDir = objFSO.GetParentFolderName(objFile) \r\n\tEnd Function",
      "\tPublic Function GetFilePath(ByVal file)\r\n\t\tEchoDX \"GetFilePath( %x )\", Array(file)\r\n\t\tDim objFile\r\n\t\tOn Error Resume Next\r\n\t\tSet objFile = objFSO.GetFile(file)\r\n\t\tOn Error GoTo 0\r\n\t\tIf IsObject(objFile) Then\r\n\t\t\tGetFilePath = objFile.Path \r\n\t\tElse\r\n\t\t\tEchoDX \"File %x not found; searching in directory %x\", Array(file,dir)\r\n\t\t\tOn Error Resume Next\r\n\t\t\tSet objFile = objFile.GetFile(objFSO.BuildPath(dir, file))\r\n\t\t\tOn Error GoTo 0\r\n\t\t\tIf IsObject(objFile) Then\r\n\t\t\t\tGetFilePath = objFile.Path \r\n\t\t\tElse\r\n\t\t\t\tGetFilePath = \"File [\" & file & \"] Not found\"\r\n\t\t\tEnd If\r\n\t\tEnd If\r\n\tEnd Function",
      "\tPublic Function GetFileName(ByVal file)\r\n\t\tGetFileName = objFSO.GetFile(file).Name\r\n\tEnd Function",
      "\tPublic Function GetFileExtn(file)\r\n\t\tGetFileExtn = \"\"\r\n\t\tOn Error Resume Next\r\n\t\tGetFileExtn = LCASE(objFSO.GetExtensionName(file))\r\n\t\tOn Error GoTo 0\r\n\tEnd Function",
      "\tPublic Function GetBaseName(ByVal file)\r\n\t\tGetBaseName = Replace(GetFileName(file), \".\" & GetFileExtn(file), \"\")\r\n\tEnd Function",
      "\tPublic Function ReadFile(file)\r\n\t\tfile = putil.Resolve(file)\r\n\t\tEchoDX \"---> File resolved to: %x\", Array(file)\r\n\t\tIf Not FileExists(file) Then \r\n\t\t\tWscript.Echo \"---> File \" & file & \" does not exists.\"\r\n\t\t\tReadFile = \"\"\r\n\t\t\tExit Function\r\n\t\tEnd If\r\n\t\tDim objFile: Set objFile = objFSO.OpenTextFile(file)\r\n\t\tReadFile = objFile.ReadAll()\r\n\t\tobjFile.Close\r\n\tEnd Function",
      "\tPublic Function FileExists(file)\r\n\t\tFileExists = objFSO.FileExists(file)\r\n\tEnd Function"
    ],
    "remaining": " class\r\n' Author: Praveen Nandagiri (pravynandas@gmail.com)\r\n' ==============================================================================================\r\n\r\nClass FSO\r\n\tPrivate dir\r\n\tPrivate objFSO\r\n\t\r\n\tPrivate Sub Class_Initialize\r\n\t\tSet objFSO = CreateObject(\"Scripting.FileSystemObject\")\r\n\t\tdir = Left(WScript.ScriptFullName,InStrRev(WScript.ScriptFullName,\"\\\"))\r\n\tEnd Sub\r\n\t\r\n\t' Update the current directory of the instance if needed\r\nPUB_SUB_0\r\n\t\r\nPUB_FUN_0\r\n\t\r\nPUB_FUN_1\r\n\t\r\nPUB_FUN_2\r\n\t\r\n\t' ===================== Sub Routines =====================\r\n\t\r\nPUB_FUN_3\r\n\t\r\nPUB_SUB_1\r\n\t\r\n\t' ===================== Function Routines =====================\r\n\t\r\nPUB_FUN_4\r\n\t\r\nPUB_FUN_5\r\n\t\r\n\t''' <summary>Returns a specified number of characters from a string.</summary>\r\n\t''' <param name=\"file\">File Name</param>\r\nPUB_FUN_6\r\n\t\r\nPUB_FUN_7\r\n\t\r\nPUB_FUN_8\r\n\t\r\nPUB_FUN_9\r\n\t\r\nPUB_FUN_10\r\n\t\r\nPUB_SUB_2\r\n\t\r\nEnd Class"
  },
  {
    "name": "ExcelUtil",
    "body": "Class ExcelUtil\r\n\r\n    Private Property Get vbext_ct_Document\r\n    vbext_ct_Document = 100\r\n    End Property\r\n    Private Property Get vbext_ct_ClassModule\r\n    vbext_ct_ClassModule = 2\r\n    End Property\r\n    Private Property Get vbext_ct_MSForm\r\n    vbext_ct_MSForm = 3\r\n    End Property\r\n    Private Property Get vbext_ct_StdModule\r\n    vbext_ct_StdModule = 1\r\n    End Property\r\n    Private Property Get vbext_ct_ActiveXDesigner\r\n    vbext_ct_ActiveXDesigner = 11\r\n    End Property\r\n    Private Property Get excel_workbook_protected_level_protected\r\n    excel_workbook_protected_level_protected = 1\r\n    End Property\r\n    Private Property Get ForReading\r\n    ForReading = 1\r\n    End Property\r\n    Private Property Get ForWriting\r\n    ForWriting = 2\r\n    End Property\r\n    Private Property Get ForAppending\r\n    ForAppending = 3\r\n    End Property\r\n    Private Property Get TristateUseDefault\r\n    TristateUseDefault = 2\r\n    End Property\r\n    Private Property Get TristateTrue\r\n    TristateTrue = 1\r\n    End Property\r\n    Private Property Get TristateFalse\r\n    TristateFalse = 0\r\n    End Property\r\n\r\n    Public Property Get GetActiveWorkbook\r\n        Set GetActiveWorkbook = ActiveWorkbook\r\n    End Property\r\n\r\n    Private Application\r\n    Private ActiveWorkbook\r\n    Private wkbSource\r\n    Private objFSO\r\n\r\n    Private Sub Class_Initialize()\r\n        Set objFSO = CreateObject(\"scripting.filesystemobject\")\r\n        set Application = createobject(\"Excel.Application\").Application\r\n        if Application is nothing then\r\n            Echo \"Unable to create Excel Application object.\"\r\n            Err.Clear\r\n            Err.Raise 50001, \"Error in Excel Class\", \"Unable to create Excel application object.\"\r\n            Class_Terminate\r\n        end if\r\n        SetVisibility False\r\n        ShowAlerts False\r\n    End Sub\r\n\r\n    Public Sub OpenWorkBook(path)\r\n        On Error Resume Next\r\n        path = putil.Resolve(path)\r\n        EchoDX \"Opening Excel Workbook at path: %x\", path\r\n        set ActiveWorkbook = Application.workbooks.Open(path)\r\n        On Error Goto 0\r\n        if Not IsObject(ActiveWorkbook) then\r\n            EchoX \"Unable to Open Excel Workbook at path %x.\", path\r\n            Err.Clear\r\n            Err.Raise 50002, \"Error in Excel Class\", \"Unable to open Excel Workbook at path \" & path\r\n        end if\r\n        ''' NOTE: This workbook must be open in Excel.\r\n        Set wkbSource = Application.Workbooks(ActiveWorkbook.Name)\r\n        EchoX \"Workbook %x opened successfully.\", wkbSource.Name\r\n    End Sub\r\n    Public SUb CloseWorkBook\r\n        On Error Resume Next\r\n        ActiveWorkbook.Close\r\n        On Error Goto 0\r\n    End Sub\r\n\r\n    Public Function isProtected\r\n        On Error Resume Next\r\n        isProtected = False\r\n        isProtected = (wkbSource.VBProject.Protection = excel_workbook_protected_level_protected)\r\n        On Error Goto 0\r\n    End Function\r\n\r\n    Public Sub SetVisibility(flag)\r\n        Application.Visible = (flag or LCase(flag) = \"true\")\r\n    End Sub\r\n    Public Sub ShowAlerts(flag)\r\n        Application.DisplayAlerts = (flag Or Lcase(flag) = \"true\")\r\n    End Sub\r\n\r\n    Public Sub ExportVBAComponents(destination)\r\n        Dim cmpComponent, bExport, szFileName\r\n\r\n        If isProtected Then\r\n            Echo \"The workbook is protected. Cannot export VB Components.\"\r\n            Exit Sub\r\n        End If\r\n\r\n\r\n        If IsNull(destination) Or destination = \"\" Then\r\n            EchoX \"Destination directory not provided. Will be uploaded to default direcotry %x\", GetActiveWorkbook.Name\r\n            destination = putil.Resolve(GetActiveWorkbook.Name)\r\n        End If\r\n\r\n        destination = objFSO.GetBaseName(destination)\r\n        destination = objFSO.BuildPath(putil.BasePath, destination)\r\n        If cFS.CreateFolder(destination) Then\r\n            EchoX \"Destination Directory successfully created at: %x\", destination\r\n        Else\r\n            EchoX \"Unable to create destination directory at [%x]. Please create it and retry.\", destination\r\n            Exit Sub\r\n        End If\r\n\r\n        If Not objFSO.FolderExists(destination) Then\r\n            EchoX \"Destination folder %x does not exists. Please create it and retry.\", destination\r\n            Exit Sub\r\n        End If\r\n        destination = ObjFSO.GetFolder(destination)\r\n\r\n        'TODO: Move objFSO code to it's own class\r\n        On Error Resume Next\r\n        EchoX \"Deleting previously exported VBA Modules in direcotry %x\", destination\r\n        objFSO.DeleteFile objFSO.BuildPath(destination, \"*.cls\"), True\r\n        objFSO.DeleteFile  objFSO.BuildPath(destination, \"*.frm\"), True\r\n        objFSO.DeleteFile  objFSO.BuildPath(destination, \"*.bas\"), True\r\n        objFSO.DeleteFile  objFSO.BuildPath(destination, \"*.frx\"), True\r\n        On Error GoTo 0\r\n        \r\n        EchoX \"Exporting VBComponents to folder: %x\", destination\r\n        For Each cmpComponent In wkbSource.VBProject.VBComponents\r\n            \r\n            bExport = True\r\n            szFileName = cmpComponent.Name\r\n\r\n            ''' Concatenate the correct filename for export.\r\n            Select Case cmpComponent.Type\r\n                Case vbext_ct_ClassModule\r\n                    szFileName = szFileName & \".cls\"\r\n                Case vbext_ct_MSForm\r\n                    szFileName = szFileName & \".frm\"\r\n                Case vbext_ct_StdModule\r\n                    szFileName = szFileName & \".bas\"\r\n                Case vbext_ct_Document\r\n                    ''' This is a worksheet or workbook object.\r\n                    ''' Don't try to export.\r\n                    bExport = False\r\n            End Select\r\n            \r\n            If bExport Then\r\n                ''' Export the component to a text file.\r\n                'EchoX \"Exporting Module %x to %x\", Array(szFileName, objFSO.BuildPath(destination, szFileName))\r\n                'On Error Resume Next\r\n                cmpComponent.Export objFSO.BuildPath(destination, szFileName)\r\n                'Echo Err.Description\r\n                'On Error Goto 0\r\n                \r\n            ''' remove it from the project if you want\r\n            '''wkbSource.VBProject.VBComponents.Remove cmpComponent\r\n            \r\n            End If\r\n        Next \r\n        Echo \"Unpacking completed succesfully.\"\r\n    End Sub\r\n\r\n    Public Sub ImportVBAComponents(source)\r\n        Dim cmpComponents, objFile\r\n        \r\n        If IsNull(source) Or source = \"\" Then\r\n            source = objFSO.GetBaseName(GetActiveWorkbook.Name)\r\n            source = objFSO.BuildPath(putil.BasePath, source)\r\n            EchoX \"Source directory not provided. Assuming default direcotry %x\", source\r\n        End If\r\n\r\n        If Not objFSO.FolderExists(source) Then\r\n            EchoX \"Unable to get source directory at: %x. Did you try exporting the scripts first?\", source\r\n            Exit Sub\r\n        End If\r\n\r\n        If isProtected Then\r\n            Echo \"The workbook is protected. Cannot export VB Components.\"\r\n            Exit Sub\r\n        End If\r\n\r\n        Set cmpComponents = wkbSource.VBProject.VBComponents\r\n\r\n        ''' Import all the code modules in the specified path\r\n        ''' to the wkbSource.\r\n        DeleteVBAComponents False\r\n\r\n        For Each objFile In objFSO.GetFolder(source).Files\r\n            If (objFSO.GetExtensionName(objFile.Name) = \"cls\") Or _\r\n                (objFSO.GetExtensionName(objFile.Name) = \"frm\") Or _\r\n                (objFSO.GetExtensionName(objFile.Name) = \"bas\") Then\r\n                cmpComponents.Import objFile.Path\r\n            End If\r\n        Next \r\n\r\n        wkbSource.save\r\n        Echo \"Packing completed succesfully.\"\r\n    End Sub\r\n\r\n    Public Sub DeleteVBAComponents(save)\r\n        Dim VBComponents, VBComp \r\n\r\n        If isProtected Then\r\n            Echo \"The workbook is protected. Cannot delete VB Components.\"\r\n            Exit Sub\r\n        End If\r\n\r\n        Echo \"About to delete the VBA components of the workbook\"\r\n        Set VBComponents = wkbSource.VBProject.VBComponents\r\n        For Each VBComp In VBComponents\r\n            If VBComp.Type = vbext_ct_Document Then\r\n                'Thisworkbook or worksheet module\r\n                'We do nothing\r\n            Else\r\n                VBComponents.Remove VBComp\r\n            End If\r\n        Next \r\n        if(save) Then wkbSource.save\r\n    End Sub\r\n\r\n    Private Sub Class_Terminate()\r\n        EchoD \"Excel Class being terminated.\"\r\n        On Error Resume Next\r\n        ShowAlerts\r\n        ActiveWorkbook.close\r\n        set ActiveWorkbook = nothing\r\n        Application.quit\r\n        set Application = nothing\r\n        On Error Goto 0\r\n    End Sub\r\n\r\nEnd Class ",
    "pubProps": [
      "    Public Property Get GetActiveWorkbook\r\n        Set GetActiveWorkbook = ActiveWorkbook\r\n    End Property"
    ],
    "pubSubs": [
      "    Public Sub OpenWorkBook(path)\r\n        On Error Resume Next\r\n        path = putil.Resolve(path)\r\n        EchoDX \"Opening Excel Workbook at path: %x\", path\r\n        set ActiveWorkbook = Application.workbooks.Open(path)\r\n        On Error Goto 0\r\n        if Not IsObject(ActiveWorkbook) then\r\n            EchoX \"Unable to Open Excel Workbook at path %x.\", path\r\n            Err.Clear\r\n            Err.Raise 50002, \"Error in Excel Class\", \"Unable to open Excel Workbook at path \" & path\r\n        end if\r\n        ''' NOTE: This workbook must be open in Excel.\r\n        Set wkbSource = Application.Workbooks(ActiveWorkbook.Name)\r\n        EchoX \"Workbook %x opened successfully.\", wkbSource.Name\r\n    End Sub",
      "    Public SUb CloseWorkBook\r\n        On Error Resume Next\r\n        ActiveWorkbook.Close\r\n        On Error Goto 0\r\n    End Sub",
      "    Public Sub SetVisibility(flag)\r\n        Application.Visible = (flag or LCase(flag) = \"true\")\r\n    End Sub",
      "    Public Sub ShowAlerts(flag)\r\n        Application.DisplayAlerts = (flag Or Lcase(flag) = \"true\")\r\n    End Sub",
      "    Public Sub ExportVBAComponents(destination)\r\n        Dim cmpComponent, bExport, szFileName\r\n\r\n        If isProtected Then\r\n            Echo \"The workbook is protected. Cannot export VB Components.\"\r\n            Exit Sub\r\n        End If\r\n\r\n\r\n        If IsNull(destination) Or destination = \"\" Then\r\n            EchoX \"Destination directory not provided. Will be uploaded to default direcotry %x\", GetActiveWorkbook.Name\r\n            destination = putil.Resolve(GetActiveWorkbook.Name)\r\n        End If\r\n\r\n        destination = objFSO.GetBaseName(destination)\r\n        destination = objFSO.BuildPath(putil.BasePath, destination)\r\n        If cFS.CreateFolder(destination) Then\r\n            EchoX \"Destination Directory successfully created at: %x\", destination\r\n        Else\r\n            EchoX \"Unable to create destination directory at [%x]. Please create it and retry.\", destination\r\n            Exit Sub\r\n        End If\r\n\r\n        If Not objFSO.FolderExists(destination) Then\r\n            EchoX \"Destination folder %x does not exists. Please create it and retry.\", destination\r\n            Exit Sub\r\n        End If\r\n        destination = ObjFSO.GetFolder(destination)\r\n\r\n        'TODO: Move objFSO code to it's own class\r\n        On Error Resume Next\r\n        EchoX \"Deleting previously exported VBA Modules in direcotry %x\", destination\r\n        objFSO.DeleteFile objFSO.BuildPath(destination, \"*.cls\"), True\r\n        objFSO.DeleteFile  objFSO.BuildPath(destination, \"*.frm\"), True\r\n        objFSO.DeleteFile  objFSO.BuildPath(destination, \"*.bas\"), True\r\n        objFSO.DeleteFile  objFSO.BuildPath(destination, \"*.frx\"), True\r\n        On Error GoTo 0\r\n        \r\n        EchoX \"Exporting VBComponents to folder: %x\", destination\r\n        For Each cmpComponent In wkbSource.VBProject.VBComponents\r\n            \r\n            bExport = True\r\n            szFileName = cmpComponent.Name\r\n\r\n            ''' Concatenate the correct filename for export.\r\n            Select Case cmpComponent.Type\r\n                Case vbext_ct_ClassModule\r\n                    szFileName = szFileName & \".cls\"\r\n                Case vbext_ct_MSForm\r\n                    szFileName = szFileName & \".frm\"\r\n                Case vbext_ct_StdModule\r\n                    szFileName = szFileName & \".bas\"\r\n                Case vbext_ct_Document\r\n                    ''' This is a worksheet or workbook object.\r\n                    ''' Don't try to export.\r\n                    bExport = False\r\n            End Select\r\n            \r\n            If bExport Then\r\n                ''' Export the component to a text file.\r\n                'EchoX \"Exporting Module %x to %x\", Array(szFileName, objFSO.BuildPath(destination, szFileName))\r\n                'On Error Resume Next\r\n                cmpComponent.Export objFSO.BuildPath(destination, szFileName)\r\n                'Echo Err.Description\r\n                'On Error Goto 0\r\n                \r\n            ''' remove it from the project if you want\r\n            '''wkbSource.VBProject.VBComponents.Remove cmpComponent\r\n            \r\n            End If\r\n        Next \r\n        Echo \"Unpacking completed succesfully.\"\r\n    End Sub",
      "    Public Sub ImportVBAComponents(source)\r\n        Dim cmpComponents, objFile\r\n        \r\n        If IsNull(source) Or source = \"\" Then\r\n            source = objFSO.GetBaseName(GetActiveWorkbook.Name)\r\n            source = objFSO.BuildPath(putil.BasePath, source)\r\n            EchoX \"Source directory not provided. Assuming default direcotry %x\", source\r\n        End If\r\n\r\n        If Not objFSO.FolderExists(source) Then\r\n            EchoX \"Unable to get source directory at: %x. Did you try exporting the scripts first?\", source\r\n            Exit Sub\r\n        End If\r\n\r\n        If isProtected Then\r\n            Echo \"The workbook is protected. Cannot export VB Components.\"\r\n            Exit Sub\r\n        End If\r\n\r\n        Set cmpComponents = wkbSource.VBProject.VBComponents\r\n\r\n        ''' Import all the code modules in the specified path\r\n        ''' to the wkbSource.\r\n        DeleteVBAComponents False\r\n\r\n        For Each objFile In objFSO.GetFolder(source).Files\r\n            If (objFSO.GetExtensionName(objFile.Name) = \"cls\") Or _\r\n                (objFSO.GetExtensionName(objFile.Name) = \"frm\") Or _\r\n                (objFSO.GetExtensionName(objFile.Name) = \"bas\") Then\r\n                cmpComponents.Import objFile.Path\r\n            End If\r\n        Next \r\n\r\n        wkbSource.save\r\n        Echo \"Packing completed succesfully.\"\r\n    End Sub",
      "    Public Sub DeleteVBAComponents(save)\r\n        Dim VBComponents, VBComp \r\n\r\n        If isProtected Then\r\n            Echo \"The workbook is protected. Cannot delete VB Components.\"\r\n            Exit Sub\r\n        End If\r\n\r\n        Echo \"About to delete the VBA components of the workbook\"\r\n        Set VBComponents = wkbSource.VBProject.VBComponents\r\n        For Each VBComp In VBComponents\r\n            If VBComp.Type = vbext_ct_Document Then\r\n                'Thisworkbook or worksheet module\r\n                'We do nothing\r\n            Else\r\n                VBComponents.Remove VBComp\r\n            End If\r\n        Next \r\n        if(save) Then wkbSource.save\r\n    End Sub"
    ],
    "pubFuncs": [
      "    Public Function isProtected\r\n        On Error Resume Next\r\n        isProtected = False\r\n        isProtected = (wkbSource.VBProject.Protection = excel_workbook_protected_level_protected)\r\n        On Error Goto 0\r\n    End Function"
    ],
    "remaining": "Class ExcelUtil\r\n\r\n    Private Property Get vbext_ct_Document\r\n    vbext_ct_Document = 100\r\n    End Property\r\n    Private Property Get vbext_ct_ClassModule\r\n    vbext_ct_ClassModule = 2\r\n    End Property\r\n    Private Property Get vbext_ct_MSForm\r\n    vbext_ct_MSForm = 3\r\n    End Property\r\n    Private Property Get vbext_ct_StdModule\r\n    vbext_ct_StdModule = 1\r\n    End Property\r\n    Private Property Get vbext_ct_ActiveXDesigner\r\n    vbext_ct_ActiveXDesigner = 11\r\n    End Property\r\n    Private Property Get excel_workbook_protected_level_protected\r\n    excel_workbook_protected_level_protected = 1\r\n    End Property\r\n    Private Property Get ForReading\r\n    ForReading = 1\r\n    End Property\r\n    Private Property Get ForWriting\r\n    ForWriting = 2\r\n    End Property\r\n    Private Property Get ForAppending\r\n    ForAppending = 3\r\n    End Property\r\n    Private Property Get TristateUseDefault\r\n    TristateUseDefault = 2\r\n    End Property\r\n    Private Property Get TristateTrue\r\n    TristateTrue = 1\r\n    End Property\r\n    Private Property Get TristateFalse\r\n    TristateFalse = 0\r\n    End Property\r\n\r\nPUB_PROP_0\r\n\r\n    Private Application\r\n    Private ActiveWorkbook\r\n    Private wkbSource\r\n    Private objFSO\r\n\r\n    Private Sub Class_Initialize()\r\n        Set objFSO = CreateObject(\"scripting.filesystemobject\")\r\n        set Application = createobject(\"Excel.Application\").Application\r\n        if Application is nothing then\r\n            Echo \"Unable to create Excel Application object.\"\r\n            Err.Clear\r\n            Err.Raise 50001, \"Error in Excel Class\", \"Unable to create Excel application object.\"\r\n            Class_Terminate\r\n        end if\r\n        SetVisibility False\r\n        ShowAlerts False\r\n    End Sub\r\n\r\nPUB_SUB_0\r\nPUB_SUB_1\r\n\r\nPUB_FUN_0\r\n\r\nPUB_SUB_2\r\nPUB_SUB_3\r\n\r\nPUB_SUB_4\r\n\r\nPUB_SUB_5\r\n\r\nPUB_SUB_6\r\n\r\n    Private Sub Class_Terminate()\r\n        EchoD \"Excel Class being terminated.\"\r\n        On Error Resume Next\r\n        ShowAlerts\r\n        ActiveWorkbook.close\r\n        set ActiveWorkbook = nothing\r\n        Application.quit\r\n        set Application = nothing\r\n        On Error Goto 0\r\n    End Sub\r\n\r\nEnd Class "
  }
]